#k8b #docker
# Info
- https://telegra.ph/Pajplajn-CICD-chto-ehto-takoe-kak-primenyaetsya-v-razrabotke-11-03

# Инструменты CI/CD
- Jenkins — бесплатная программная среда с открытым исходным кодом (в виде сервера) созданная специально для выполнения непрерывной интеграции ПО. Продукт написан на Java, поэтому работает в Windows, macOS и других Unix-подобных операционных системах.
- CircleCI — инструмент CI/CD, выполненный в виде веб-сервиса, который позволяет полностью автоматизировать весь пайплайн, начиная от создания кода и заканчивая тестированием и развертыванием. 
- TeamCity — сервер управления сборкой и непрерывной интеграцией от JetBrains, ориентированный на DevOps-команды. Работает в среде Java и интегрируется с Visual Studio и IDE. Может быть установлен как на серверах Windows, так и на Linux, а также поддерживает .NET-проекты.
- Bamboo — сервер непрерывной интеграции, который автоматизирует управление выпусками приложений. Является одним из продуктов компании Atlassian. Охватывает сборку, функциональное тестирование, назначение версий, пометку выпусков, развертывание и активацию новых версий в рабочей среде.
# Этапы CI/CD
- ### Триггер
	- Пайплайн должен запускаться автоматически каждый раз, когда фиксируется отправка нового кода в репозиторий. Есть много вариантов достичь этого.
		- Например, инструмент CI/CD (например, Jenkins) может вести опрос («poll») репозитория Git, либо наоборот, определенный «hook» (например, Git Webhooks) будет отправлять push-уведомление инструменту CI/CD каждый раз, когда разработчик делает push в системе контроля версий.
- ### Проверка кода.
	- Инструмент CI/CD извлекает код из репозитория (через «hook» или «poll») вместе с информацией о том, какой конкретный коммит вызвал триггер пайплайна и как требуется выполнять этапы пайплайна.
		- На этой стадии могут быть запущены инструменты статического анализа кода, останавливающие выполнения пайплайна в случае выявления ошибки. Если все в порядке, CI/CD процесс продолжается дальше.
- ### Компиляция кода. 
	- Очевидно, инструмент CI/CD должен иметь доступ ко всем инструментам сборки, которые необходимы для компиляции кода. Например, если приложение написано на Java, то могут использоваться Maven или Gradle.
		- Кстати, лучше всего, чтобы сборка происходила в чистой «среде». Для этих целей можно использовать контейнеризацию — Docker, например
- Unit-тестирование.
	- Важнейший элемент пайплайна — модульное тестирование или unit testing. Для этого используются специальные библиотеки для каждого конкретного языка программирования.
		- Скомпилированное приложения запускается с использованием тестов, если выполнение завершается без ошибки, значит можно переходить к следующему этапу пайплайна.
- Упаковка кода.
	- Если все тесты пройдены, то перед доставкой пользователю приложение нужно упаковать в конечный «build».
		- Например, если код на Java, то создается JAR-файл. А если ваше приложение размещено в контейнере Docker, имеет смысл создать образ Docker.
- ### Приемочное тестирование.
	- По сути, это способ убедиться, что ПО соответствует всем необходимым требованиям — либо клиента, либо заявлениям самого разработчика.
		- Однако, так же, как и модульные, приемочные тесты выполняются автоматически. Иными словами, требования и желаемый результат указывается в формате, который понятен вычислительной система, а значит может быть автоматизирован и неоднократно протестирован — подобно модульным тестам.
- ### Доставка и развертывание.
	- На этом этапе уже существует готовый к развертыванию программный продукт, которые необходимо доставить в рабочую среду клиента и корректно его установить.
		- Для непрерывного развертывания нужна производственная среда. Например, это может быть публичное облако со своим собственным API или инструмент Spinnaker, который работает системой оркестрации контейнеров Kubernetes и всеми популярными облаками — Google Cloud Platform, AWS, Microsoft Azure and Oracle Cloud.
	- Это этап — конец пайплайна. В следующий раз, когда какой-то разработчик отправит новый код в репозиторий, процесс будет запущен снова.

# CI/CD на практике
- Стандартный процесс
	- ради добавления в продукт новой функции создается отдельная ветка в системе контроля версий (например, Git). В ней пишется код, после чего локально тестируется.
	- Когда новая фича готова, программист делает pull request и просит старшего коллегу сделать «ревью», чтобы принять результаты в основную ветку.
	- Далее обновленная кодовая база «деплоится» в dev-окружение. Все делается вручную.
- Если вы тратите 25 часов на разработку и 2 часа на деплой — это более-менее нормальное соотношение. Однако, если вы тратите 20 минут на создание «фичи», а на деплой уходят те же 2 часа — это проблема.
- У вас есть два пути:
	- Вносить изменения в основную ветку реже, накапливая большой pull request. Только вот ревьюировать такие объемы кода будет уже сложнее.
	- Организовать CI/CD пайплайн для автоматической сборки, тестирования и деплоя.
- В GitLab автоматизированными процессами занимается служба GitLab Runner — изолированная виртуальная машина, выполняющий задания пайплайна.
	- аннеры программируются с помощью YAML-скриптов